-- | DGM.AbsoluteZero — Self-play task generation and solving (SPEC.md §1.2, §5).
--
-- Implements the dual-role Absolute Zero loop:
--
--  * /Proposer/: generates computational tasks optimised for "learnability".
--    Tasks too easy (trivially solvable by the current agent) score 0.
--    Tasks too hard (the agent cannot solve them) also score 0.
--    Only tasks at the agent's current Pareto frontier score positively.
--
--  * /Solver/: attempts to solve the proposed tasks using the expression
--    language and rewriting engine.  Accuracy is measured by deterministic
--    evaluation against the task's built-in verifier.
--
-- By combining DGM's archive-based evolution with Absolute Zero's endogenous
-- task generation, the system can improve indefinitely without external data.
--
-- Phase G extends the Task DSL with 'SelfModTask' and wires the Proposer to
-- generate self-modification tasks from the live module graph.
module DGM.AbsoluteZero
  ( -- * Task DSL
    Task(..)
  , TaskSpec(..)
  , TaskType(..)
  , TaskDifficulty
    -- * Phase G Task DSL extension
  , SelfModSpec(..)
  , SelfModGoal(..)
  , SelfModConstraint(..)
    -- * Proposer
  , Proposer(..)
  , ProposerPhase(..)
  , defaultProposer
  , proposeTask
  , proposeSelfModTask
    -- * Solver
  , SolverResult(..)
  , solveTask
  , solveSelfModTask
    -- * Learnability and accuracy rewards
  , learnabilityScore
  , accuracyReward
    -- * Self-play loop
  , SelfPlayConfig(..)
  , defaultSelfPlayConfig
  , runSelfPlayStep
  ) where

import Control.Exception (catch, IOException)
import Control.Monad (unless)
import Data.Text (Text)
import qualified Data.Text as T
import System.IO (hPutStrLn, stderr)
import qualified Data.Text.IO as TIO
import qualified Data.Map.Strict as Map
import Data.Set (Set)
import qualified Data.Set as Set
import System.Directory (doesFileExist)
import System.FilePath ((</>))
import System.Random (randomRIO)
import DGM.AST
import DGM.Types
import DGM.HsAST (HsMutation(hmDescription))
import DGM.Rewriting (rewrite, defaultConfig, defaultRules)
import DGM.ModGraph (ModuleGraph(..), buildModuleGraph)
import DGM.Oracle (newOracleEnv, proposeMutation)
import DGM.SelfMod (discoverSources)

-- ─────────────────────────────────────────────────────────────────────────────
-- Phase G: Task DSL extension
-- ─────────────────────────────────────────────────────────────────────────────

-- | Discriminated union covering both expression tasks (original) and
-- self-modification tasks (Phase G).
data TaskSpec
  = ExprTask Expr            -- ^ Existing path: evaluate/simplify an expression.
  | SelfModTask SelfModSpec  -- ^ Phase G: mutate own Haskell source.
  deriving (Eq)

instance Show TaskSpec where
  show (ExprTask e)    = "ExprTask (" <> T.unpack (prettyExpr e) <> ")"
  show (SelfModTask s) = "SelfModTask " <> show s

-- | Specification for a self-modification task.
data SelfModSpec = SelfModSpec
  { smsTargetModule  :: ModuleName          -- ^ Module to be mutated.
  , smsGoal          :: SelfModGoal         -- ^ What kind of change to make.
  , smsConstraints   :: [SelfModConstraint] -- ^ Safety constraints.
  } deriving (Show, Eq)

-- | The category of self-modification the agent should perform.
data SelfModGoal
  = AddRewriteRule   Text        -- ^ Add a named rewrite rule to Rewriting.hs (source-level).
  | AddDynamicRule   Text        -- ^ Add a dynamic ExprF rewrite rule via HintBridge (in-memory, no recompile).
  | ImproveScoring   Text        -- ^ Improve a named scoring function.
  | ReduceComplexity ModuleName  -- ^ Reduce cyclomatic complexity of module.
  | ExtendArchive    Text        -- ^ Add a new field/capability to Archive.
  | AddCapability    Text        -- ^ Add a wholly new module/feature.
  deriving (Show, Eq)

-- | Safety constraints that the solver must respect when solving a 'SelfModTask'.
data SelfModConstraint
  = PreserveExports  -- ^ Mutation must not remove existing exports.
  | MaintainTests    -- ^ Mutation must not decrease test count.
  | MaxDelta Int     -- ^ Mutation may touch at most N lines.
  deriving (Show, Eq)

-- ─────────────────────────────────────────────────────────────────────────────
-- Task DSL
-- ─────────────────────────────────────────────────────────────────────────────

-- | A computational task generated by the Proposer.
data Task = Task
  { taskId          :: Text
  , taskType        :: TaskType
  , taskDifficulty  :: TaskDifficulty
  , taskDescription :: Text
  , taskSpec        :: TaskSpec              -- ^ Task payload (ExprTask or SelfModTask).
  , taskVerify      :: Expr -> EvalEnv -> Bool  -- ^ Deterministic verifier (ExprTask only).
  }

-- | Difficulty estimate in [0, 1]; 0 = trivial, 1 = impossible.
type TaskDifficulty = Double

data TaskType
  = ArithmeticTask    -- ^ Pure arithmetic computation.
  | RecursiveTask     -- ^ Requires recursive definition.
  | OptimisationTask  -- ^ Improve an existing expression.
  | EquivalenceTask   -- ^ Prove two expressions equivalent.
  deriving (Show, Eq, Enum, Bounded)

-- ─────────────────────────────────────────────────────────────────────────────
-- Built-in task library
-- ─────────────────────────────────────────────────────────────────────────────

-- | Compare two evaluation results by converting to Text.
-- Avoids the need for Eq on Value (which contains functions).
eqResults :: Either Text Value -> Either Text Value -> Bool
eqResults a b = showResult a == showResult b
  where
    showResult (Left  e) = "Err:" <> e
    showResult (Right v) = "Ok:" <> T.pack (show v)

-- | Compute @n!@ for small @n@.
factorialTask :: Int -> Task
factorialTask n = Task
  { taskId          = "factorial-" <> T.pack (show n)
  , taskType        = RecursiveTask
  , taskDifficulty  = fromIntegral n / 20.0
  , taskDescription = "Compute " <> T.pack (show n) <> "!"
  , taskSpec        = ExprTask (lit (factorial n))
  , taskVerify      = \expr env ->
      case evalExpr env expr of
        Right (VInt v) -> v == factorial n
        _              -> False
  }
  where
    factorial 0 = 1
    factorial k = k * factorial (k - 1)

-- | Compute the @n@-th Fibonacci number.
fibTask :: Int -> Task
fibTask n = Task
  { taskId          = "fib-" <> T.pack (show n)
  , taskType        = RecursiveTask
  , taskDifficulty  = fromIntegral n / 30.0
  , taskDescription = "Compute fib(" <> T.pack (show n) <> ")"
  , taskSpec        = ExprTask (lit (fib n))
  , taskVerify      = \expr env ->
      case evalExpr env expr of
        Right (VInt v) -> v == fib n
        _              -> False
  }
  where
    fib 0 = 0
    fib 1 = 1
    fib k = fib (k-1) + fib (k-2)

-- | Simplify an arithmetic expression.
simplifyTask :: Expr -> Task
simplifyTask expr = Task
  { taskId          = "simplify"
  , taskType        = OptimisationTask
  , taskDifficulty  = 0.3
  , taskDescription = "Simplify: " <> prettyExpr expr
  , taskSpec        = ExprTask expr
  , taskVerify      = \candidate env ->
      -- Verifier: candidate must evaluate to same value as original.
      -- Use show-comparison to avoid Eq on Value (which contains functions).
      eqResults (evalExpr env candidate) (evalExpr env expr)
  }

-- | Arithmetic equality task.
equivTask :: Expr -> Expr -> Task
equivTask e1 e2 = Task
  { taskId          = "equiv"
  , taskType        = EquivalenceTask
  , taskDifficulty  = 0.5
  , taskDescription = prettyExpr e1 <> " ≡ " <> prettyExpr e2
  , taskSpec        = ExprTask e1
  , taskVerify      = \candidate env ->
      eqResults (evalExpr env candidate) (evalExpr env e2)
  }

-- | The task library, indexed by approximate difficulty.
taskLibrary :: [(TaskDifficulty, Task)]
taskLibrary =
  [ (0.05, factorialTask 3)
  , (0.1,  factorialTask 5)
  , (0.2,  factorialTask 8)
  , (0.15, fibTask 6)
  , (0.25, fibTask 10)
  , (0.35, fibTask 15)
  , (0.3,  simplifyTask (binop "+" (lit 3) (lit 4)))
  , (0.4,  simplifyTask (binop "*" (lit 2) (binop "+" (lit 3) (lit 0))))
  , (0.5,  equivTask (binop "+" (lit 2) (lit 3)) (lit 5))
  ]

-- ─────────────────────────────────────────────────────────────────────────────
-- Proposer
-- ─────────────────────────────────────────────────────────────────────────────

-- | Selects the Proposer's current mode of operation.
--
-- * 'ExprMode'    — generate 'ExprTask' tasks (original Absolute Zero loop).
-- * 'SelfModMode' — generate 'SelfModTask' tasks (Phase G autonomous loop).
data ProposerPhase = ExprMode | SelfModMode
  deriving (Show, Eq)

-- | The Proposer's state and parameters.
data Proposer = Proposer
  { propCurrentDifficulty :: Double        -- ^ Current estimated agent capability.
  , propExplorationRate   :: Double        -- ^ How far beyond frontier to explore.
  , propCurrentPhase      :: ProposerPhase -- ^ Current operating mode.
  , propSelfModCounter    :: Int           -- ^ ExprPhase cycles since last SelfModPhase.
  , propSolvedTasks       :: Set Text      -- ^ Task IDs already solved; avoids re-proposing.
  }

defaultProposer :: Proposer
defaultProposer = Proposer
  { propCurrentDifficulty = 0.2
  , propExplorationRate   = 0.15
  , propCurrentPhase      = ExprMode
  , propSelfModCounter    = 0
  , propSolvedTasks       = Set.empty
  }

-- | Propose a task and return the updated 'Proposer'.
--
-- Dispatches on 'propCurrentPhase': 'ExprMode' yields an expression task;
-- 'SelfModMode' yields a self-modification task targeting the live module graph.
proposeTask :: Proposer -> IO (Task, Proposer)
proposeTask p
  | propCurrentPhase p == SelfModMode = proposeSelfModTask p
  | otherwise                         = proposeExprTask p

-- | Propose an expression task at the agent's current Pareto frontier.
--
-- Filters out already-solved tasks so the Proposer never loops on the same
-- task.  When the entire library is exhausted, generates a fresh arithmetic
-- task procedurally.  Increments 'propSelfModCounter' so that 'runCycleN'
-- can trigger phase transitions at the 'ccSelfModRateLimit' cadence.
proposeExprTask :: Proposer -> IO (Task, Proposer)
proposeExprTask prop = do
  let target = propCurrentDifficulty prop + propExplorationRate prop
      solved = propSolvedTasks prop
      avail  = filter (\(_, t) -> taskId t `Set.notMember` solved) taskLibrary
  noise <- randomRIO (-0.05, 0.05)
  task <- if null avail
            then generateProceduralTask (target + noise)
            else pure (pickNearest (target + noise) avail)
  let newProp = prop { propSelfModCounter = propSelfModCounter prop + 1 }
  pure (task, newProp)
  where
    pickNearest t tasks =
      snd $ foldr1 (\a b -> if abs (fst a - t) < abs (fst b - t) then a else b) tasks

-- | Generate a fresh arithmetic simplification task procedurally.
--
-- Used when the static task library is exhausted (all tasks solved).
-- Produces a unique task ID so the Proposer can track it in 'propSolvedTasks'.
generateProceduralTask :: TaskDifficulty -> IO Task
generateProceduralTask diff = do
  a     <- randomRIO (1, 20 :: Int)
  b     <- randomRIO (1, 20 :: Int)
  opIdx <- randomRIO (0, 1 :: Int)
  let op   = if (opIdx :: Int) == 0 then "+" else "*"
      expr = binop op (lit a) (lit b)
      base = simplifyTask expr
  pure base
    { taskId         = "proc-" <> T.pack (show a) <> op <> T.pack (show b)
    , taskDifficulty = diff
    }

-- | Propose a self-modification task targeting the live module graph.
--
-- Selects a non-safeguarded module with mutation potential.  Prefers
-- @DGM.Rewriting@ as the bootstrap target (adding rewrite rules is low-risk
-- and directly improves system capability).  Resets 'propSelfModCounter' and
-- returns to 'ExprMode' after proposing.
--
-- __Oracle integration__: if an oracle API key is present, queries the LLM
-- for a specific rule name to use as the goal.  Falls back to
-- @AddRewriteRule "etaReduce"@ when the oracle is unavailable.
proposeSelfModTask :: Proposer -> IO (Task, Proposer)
proposeSelfModTask prop = do
  fps   <- discoverSources
  graph <- buildModuleGraph fps
  let allMods    = Map.keys (mgModules graph)
      nonGuarded = filter (`Set.notMember` safeguardedModules) allMods
      targetMod  = case filter (== "DGM.Rewriting") nonGuarded of
                     (m : _) -> m
                     _       -> case nonGuarded of
                                  (m : _) -> m
                                  []      -> "DGM.Rewriting"
  -- Ask oracle to suggest a goal for the target module, if available.
  goal <- oracleGoalFor targetMod
  let spec = SelfModSpec
               { smsTargetModule = targetMod
               , smsGoal         = goal
               , smsConstraints  = [PreserveExports, MaintainTests]
               }
      diff = propCurrentDifficulty prop + propExplorationRate prop
      task = Task
               { taskId          = "selfmod-" <> targetMod
               , taskType        = OptimisationTask
               , taskDifficulty  = diff
               , taskDescription = "Add rewrite rule to " <> targetMod
               , taskSpec        = SelfModTask spec
               , taskVerify      = \_ _ -> True   -- not used for SelfModTask
               }
      newProp = prop
                  { propCurrentPhase   = ExprMode
                  , propSelfModCounter = 0
                  }
  pure (task, newProp)

-- | Query the oracle for a mutation goal for the given module.
--
-- Maps the module name to a source file path, reads the source, calls
-- 'proposeMutation', and extracts a goal name from the returned mutation
-- description.  Falls back to @AddRewriteRule "etaReduce"@ when:
--
--   * No oracle key is present.
--   * The module source file cannot be read.
--   * The oracle call fails or returns @Left@.
--
-- Every third call (determined by a random roll) proposes an
-- 'AddDynamicRule' goal instead of 'AddRewriteRule', directing the
-- 'DGM.Cycle' SelfModPhase hint sub-step to target the in-memory rule set
-- via HintBridge rather than modifying source on disk.
oracleGoalFor :: T.Text -> IO SelfModGoal
oracleGoalFor targetMod = do
  roll <- randomRIO (0 :: Int, 2)
  mEnv <- newOracleEnv
  case mEnv of
    Nothing  ->
      -- No oracle available: use dynamic rule goal as safe fallback.
      return (AddDynamicRule "fmap-increment")
    Just env -> do
      let modPath = "src" </> T.unpack (T.replace "." "/" targetMod) <> ".hs"
      exists <- doesFileExist modPath
      if not exists
        then do
          hPutStrLn stderr ("DGM.AbsoluteZero: module file not found: " ++ modPath)
          return (AddDynamicRule "fmap-increment")
        else do
          src <- TIO.readFile modPath
                   `catch` (\(_ :: IOException) -> return "")
          eResult <- proposeMutation env modPath src []
          case eResult of
            Left err -> do
              unless ("build with -f+with-oracle" `T.isInfixOf` err) $
                hPutStrLn stderr ("DGM.AbsoluteZero: oracle error for "
                                  ++ T.unpack targetMod ++ ": " ++ T.unpack err)
              return (AddDynamicRule "fmap-increment")
            Right mut ->
              -- Every third oracle response targets the dynamic rule set.
              return $ if roll == 0
                then AddDynamicRule (hmDescription mut)
                else AddRewriteRule (hmDescription mut)

-- ─────────────────────────────────────────────────────────────────────────────
-- Solver
-- ─────────────────────────────────────────────────────────────────────────────

-- | The result of the Solver attempting a task.
data SolverResult = SolverResult
  { srTaskId    :: Text
  , srSolution  :: Maybe Expr
  , srAccuracy  :: Double
  , srStepsUsed :: Int
  } deriving (Show)

-- | Attempt to solve a task; dispatches on 'taskSpec'.
solveTask :: Task -> IO SolverResult
solveTask task = case taskSpec task of
  ExprTask expr    -> solveExprTask task expr
  SelfModTask spec -> solveSelfModTask task spec

-- | Solve an expression task using the rewriting engine.
solveExprTask :: Task -> Expr -> IO SolverResult
solveExprTask task expr = do
  let (simplified, steps, _) = rewrite defaultConfig defaultRules expr
  let env = Map.fromList [("n", VInt 5), ("x", VInt 3), ("y", VInt 4)]
  let acc = if taskVerify task simplified env then 1.0 else 0.0
  pure SolverResult
    { srTaskId    = taskId task
    , srSolution  = if acc > 0 then Just simplified else Nothing
    , srAccuracy  = acc
    , srStepsUsed = steps
    }

-- | Feasibility check for a self-modification task (Phase G).
--
-- Returns 'srAccuracy' = 0.0 if the target module is in 'safeguardedModules'
-- (autonomous mutation forbidden).  For feasible targets the score is the
-- learnability reward at the task's difficulty level.  'srSolution' is always
-- 'Nothing' — the "solution" is the mutation, applied by the full SelfMod
-- pipeline in 'DGM.Cycle.runSelfModCycle'.
solveSelfModTask :: Task -> SelfModSpec -> IO SolverResult
solveSelfModTask task spec = do
  let targetMod = smsTargetModule spec
      feasible  = targetMod `Set.notMember` safeguardedModules
      score     = if feasible
                    then learnabilityScore (taskDifficulty task) (taskDifficulty task)
                    else 0.0
  pure SolverResult
    { srTaskId    = taskId task
    , srSolution  = Nothing
    , srAccuracy  = score
    , srStepsUsed = 0
    }

-- ─────────────────────────────────────────────────────────────────────────────
-- Reward functions
-- ─────────────────────────────────────────────────────────────────────────────

-- | Learnability reward for the Proposer (SPEC.md §1.2).
--
-- A task at the exact frontier of agent capability yields reward 1.
-- Too easy or too hard → reward approaches 0.
-- For 'SelfModTask', capability is compared to module complexity; the reward
-- peaks when capability ≈ complexity (Phase G acceptance criterion).
learnabilityScore
  :: Double  -- ^ Agent's current difficulty / capability estimate.
  -> Double  -- ^ Proposed task difficulty (or module complexity for SelfModTask).
  -> Double
learnabilityScore capability difficulty =
  let delta = abs (difficulty - capability)
      sigma = 0.15   -- Width of the Gaussian reward window.
  in  exp (- (delta * delta) / (2 * sigma * sigma))

-- | Accuracy reward for the Solver (SPEC.md §1.2).
--
-- Returns the raw pass/fail ratio from the verifiable feedback.
accuracyReward :: SolverResult -> Double
accuracyReward = srAccuracy

-- ─────────────────────────────────────────────────────────────────────────────
-- Self-play loop step
-- ─────────────────────────────────────────────────────────────────────────────

data SelfPlayConfig = SelfPlayConfig
  { spProposer       :: Proposer
  , spAdaptRate      :: Double  -- ^ How fast difficulty estimate adapts.
  }

defaultSelfPlayConfig :: SelfPlayConfig
defaultSelfPlayConfig = SelfPlayConfig
  { spProposer  = defaultProposer
  , spAdaptRate = 0.05
  }

-- | Run one Absolute Zero self-play step.
--
-- Returns the updated @Proposer@ (with adapted difficulty estimate,
-- incremented 'propSelfModCounter', and the solved task recorded) and
-- the full @SolverResult@.
runSelfPlayStep :: SelfPlayConfig -> IO (Proposer, SolverResult)
runSelfPlayStep cfg = do
  (task, prop') <- proposeTask (spProposer cfg)
  result <- solveTask task
  let acc    = accuracyReward result
      cap    = propCurrentDifficulty prop'
      -- Adapt: if solved, raise difficulty.  If failed, lower slightly.
      -- Partial credit (0 < acc < 1) gives a proportional gradient rather
      -- than freezing the difficulty estimate.
      newCap
        | acc >= 1.0 = min 1.0 (cap + spAdaptRate cfg)
        | acc <= 0.0 = max 0.0 (cap - spAdaptRate cfg * 0.5)
        | otherwise  = cap + (acc - 0.5) * spAdaptRate cfg
      -- Record solved tasks so they are not re-proposed.
      newSolved
        | acc >= 1.0 = Set.insert (taskId task) (propSolvedTasks prop')
        | otherwise  = propSolvedTasks prop'
      newProp = prop'
        { propCurrentDifficulty = newCap
        , propSolvedTasks       = newSolved
        }
  pure (newProp, result)
