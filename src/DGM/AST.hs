-- | DGM.AST — Abstract syntax tree representation with recursion-scheme support.
--
-- This module provides the fixed-point type infrastructure (SPEC.md §4) that
-- powers the hylomorphic evolutionary control loop.  Rather than importing an
-- external @recursion-schemes@ package, the core morphisms are implemented
-- directly here so the module is self-contained and highly legible.
--
-- The @ExprF@ functor is a simplified Haskell-expression language.  In the
-- full system it would wrap GHC's @HsExpr@; here it is rich enough to
-- demonstrate all three morphisms and the deforestation / fusion properties
-- described in SPEC.md §4.2.
{-# LANGUAGE UndecidableInstances #-}
module DGM.AST
  ( -- * Fixed-point combinator
    Fix(..)
    -- * Recursion-scheme morphisms
  , cata
  , ana
  , hylo
  , para
    -- * Expression base functor
  , ExprF(..)
  , Expr
    -- * Smart constructors
  , lit, var, app, lam, letE, ifE, binop
    -- * Pretty-printing
  , prettyExpr
    -- * Evaluation (pure interpreter)
  , EvalEnv
  , Value(..)
  , evalExpr
    -- * Mutation helpers
  , substituteVar
  , countNodes
  , collectVars
    -- * Bootstrapping
  , bootstrapExpr
  , exprToASTNode
  ) where

import Data.Map.Strict (Map)
import qualified Data.Map.Strict as Map
import Data.Set (Set)
import qualified Data.Set as Set
import Data.Text (Text)
import qualified Data.Text as T
import DGM.Types (ASTNode(..), ASTNodeType(..))

-- ─────────────────────────────────────────────────────────────────────────────
-- Fixed-point and morphisms
-- ─────────────────────────────────────────────────────────────────────────────

-- | The fixed-point type.  @Fix f@ is isomorphic to the (possibly infinite)
-- tree whose branching structure is described by @f@.
newtype Fix f = Fix { unFix :: f (Fix f) }

instance (Show (f (Fix f))) => Show (Fix f) where
  show (Fix x) = "Fix (" ++ show x ++ ")"

-- | Structural equality for fixed-point trees.
--
-- This mutual-recursive instance is resolved by GHC's superclass solver:
-- @Eq (ExprF (Fix ExprF))@ holds because @ExprF@ derives @Eq@ and
-- @Fix ExprF@ satisfies @Eq (Fix ExprF)@ by this very instance.
instance (Eq (f (Fix f))) => Eq (Fix f) where
  Fix a == Fix b = a == b

-- | /Catamorphism/ — a fold over a recursive structure (SPEC.md §4.1).
--
-- The catamorphism collapses the tree of hypothesised mutations generated by
-- the anamorphism into a single best candidate by applying the algebra at
-- every node from leaves to root.
cata :: Functor f => (f a -> a) -> Fix f -> a
cata alg = alg . fmap (cata alg) . unFix

-- | /Anamorphism/ — an unfold that builds a recursive structure from a seed
-- (SPEC.md §4.1).
--
-- In the evolutionary loop the seed is the current inefficiency or task spec;
-- the corecursion unfolds it into a tree of candidate AST mutations.
ana :: Functor f => (a -> f a) -> a -> Fix f
ana coalg = Fix . fmap (ana coalg) . coalg

-- | /Hylomorphism/ — the composition @cata alg . ana coalg@ (SPEC.md §4.1).
--
-- GHC's "deforestation" (stream fusion) pass eliminates the intermediate tree
-- during compilation, so the full hypothesis space is explored without ever
-- materialising it in heap.  This is the mathematical kernel of the
-- Zero Data Cycle's explore-then-refine loop.
hylo :: Functor f => (f b -> b) -> (a -> f a) -> a -> b
hylo alg coalg = alg . fmap (hylo alg coalg) . coalg

-- | /Paramorphism/ — like a catamorphism but the algebra receives both the
-- folded value *and* the original subtree, enabling history-aware rewriting.
para :: Functor f => (f (Fix f, a) -> a) -> Fix f -> a
para alg t = alg $ fmap (\x -> (x, para alg x)) (unFix t)

-- ─────────────────────────────────────────────────────────────────────────────
-- Expression base functor
-- ─────────────────────────────────────────────────────────────────────────────

-- | The /base functor/ of the expression language.
--
-- @ExprF a@ is the non-recursive shape; @Fix ExprF@ is the recursive tree.
-- Every field that would be @Expr@ (i.e. a recursive child) is instead @a@,
-- which makes the type amenable to @fmap@ and therefore to all three morphisms.
data ExprF a
  = LitF  Int              -- ^ Integer literal
  | BoolF Bool             -- ^ Boolean literal
  | VarF  Text             -- ^ Variable reference
  | AppF  a a              -- ^ Function application @f x@
  | LamF  Text a           -- ^ Lambda abstraction @\x -> body@
  | LetF  Text a a         -- ^ Let binding  @let x = val in body@
  | IfF   a a a            -- ^ Conditional  @if p then t else f@
  | BinOpF Text a a        -- ^ Binary operator (add, mul, eq, …)
  | UnitF                  -- ^ Unit value @()@
  deriving (Functor, Foldable, Traversable, Show, Eq)

-- | @Expr@ is the recursive fixed-point of @ExprF@.
type Expr = Fix ExprF

-- ─────────────────────────────────────────────────────────────────────────────
-- Smart constructors
-- ─────────────────────────────────────────────────────────────────────────────

lit   :: Int -> Expr
lit n = Fix (LitF n)

var   :: Text -> Expr
var v = Fix (VarF v)

app   :: Expr -> Expr -> Expr
app f x = Fix (AppF f x)

lam   :: Text -> Expr -> Expr
lam v b = Fix (LamF v b)

letE  :: Text -> Expr -> Expr -> Expr
letE v e b = Fix (LetF v e b)

ifE   :: Expr -> Expr -> Expr -> Expr
ifE p t f = Fix (IfF p t f)

binop :: Text -> Expr -> Expr -> Expr
binop op l r = Fix (BinOpF op l r)

-- ─────────────────────────────────────────────────────────────────────────────
-- Pretty-printer (catamorphism)
-- ─────────────────────────────────────────────────────────────────────────────

-- | Convert an @Expr@ to a human-readable Haskell-like string.
--
-- This is a simple catamorphism: the algebra maps each @ExprF Text@ to the
-- pretty-printed @Text@ by assembling child strings.
prettyExpr :: Expr -> Text
prettyExpr = cata prettyAlg
  where
    prettyAlg :: ExprF Text -> Text
    prettyAlg = \case
      LitF  n     -> T.pack (show n)
      BoolF b     -> if b then "True" else "False"
      VarF  v     -> v
      AppF  f x   -> "(" <> f <> " " <> x <> ")"
      LamF  v b   -> "(\\" <> v <> " -> " <> b <> ")"
      LetF  v e b -> "let " <> v <> " = " <> e <> " in " <> b
      IfF   p t f -> "if " <> p <> " then " <> t <> " else " <> f
      BinOpF op l r -> "(" <> l <> " " <> op <> " " <> r <> ")"
      UnitF       -> "()"

-- ─────────────────────────────────────────────────────────────────────────────
-- Pure interpreter (catamorphism)
-- ─────────────────────────────────────────────────────────────────────────────

-- | Runtime values produced by the pure interpreter.
data Value
  = VInt  Int
  | VBool Bool
  | VFun  (Value -> Either Text Value)
  | VUnit

instance Show Value where
  show (VInt  n) = show n
  show (VBool b) = show b
  show (VFun  _) = "<function>"
  show VUnit     = "()"

-- | Structural equality for values.
--
-- @VFun@ constructors are always unequal to each other (functions are not
-- comparable in general); this is sound for test assertions on concrete values.
instance Eq Value where
  VInt  a == VInt  b = a == b
  VBool a == VBool b = a == b
  VUnit   == VUnit   = True
  _       == _       = False

type EvalEnv = Map Text Value

-- | Evaluate an expression in a given environment.
--
-- Returns @Left err@ on type errors or unbound variables.
-- Uses a direct recursive descent rather than a catamorphism so that
-- 'LamF' can close over the current environment and 'LetF' can extend it
-- (including recursive @let@ bindings via Haskell's lazy evaluation).
evalExpr :: EvalEnv -> Expr -> Either Text Value
evalExpr env (Fix node) = case node of
  LitF  n     -> Right (VInt n)
  BoolF b     -> Right (VBool b)
  UnitF       -> Right VUnit
  VarF  v     ->
    maybe (Left $ "Unbound variable: " <> v) Right (Map.lookup v env)
  AppF  fe xe -> do
    fv <- evalExpr env fe
    xv <- evalExpr env xe
    case fv of
      VFun g -> g xv
      _      -> Left "Cannot apply non-function"
  LamF v body ->
    -- Proper closure: captures the current environment.
    Right $ VFun $ \x -> evalExpr (Map.insert v x env) body
  LetF v e body ->
    -- Tie the knot for recursive let: env' refers to itself, which is sound
    -- in Haskell's lazy evaluation model.  If evaluation of 'e' diverges or
    -- errors, the error surfaces when 'body' forces 'selfVal'.
    let env'    = Map.insert v selfVal env
        selfVal = case evalExpr env' e of
                    Right val -> val
                    Left  _   -> VUnit   -- error surfaces via body evaluation
    in  evalExpr env' body
  IfF pe te fe -> do
    pv <- evalExpr env pe
    case pv of
      VBool True  -> evalExpr env te
      VBool False -> evalExpr env fe
      _           -> Left "Condition must be Bool"
  BinOpF op le re -> do
    lv <- evalExpr env le
    rv <- evalExpr env re
    applyBinOp op lv rv

applyBinOp :: Text -> Value -> Value -> Either Text Value
applyBinOp op l r = case (op, l, r) of
  ("+",  VInt a, VInt b)  -> Right (VInt  (a + b))
  ("-",  VInt a, VInt b)  -> Right (VInt  (a - b))
  ("*",  VInt a, VInt b)  -> Right (VInt  (a * b))
  ("==", VInt a, VInt b)  -> Right (VBool (a == b))
  ("<",  VInt a, VInt b)  -> Right (VBool (a < b))
  (">",  VInt a, VInt b)  -> Right (VBool (a > b))
  ("&&", VBool a, VBool b) -> Right (VBool (a && b))
  ("||", VBool a, VBool b) -> Right (VBool (a || b))
  _                       -> Left $ "Unknown op or type mismatch: " <> op

-- ─────────────────────────────────────────────────────────────────────────────
-- Mutation helpers (catamorphisms and paramorphisms)
-- ─────────────────────────────────────────────────────────────────────────────

-- | Substitute all occurrences of a variable name with a given expression.
substituteVar :: Text -> Expr -> Expr -> Expr
substituteVar target replacement = cata subAlg
  where
    subAlg :: ExprF Expr -> Expr
    subAlg (VarF v)
      | v == target = replacement
      | otherwise   = var v
    subAlg other    = Fix other

-- | Count the total number of AST nodes (for complexity metrics).
countNodes :: Expr -> Int
countNodes = cata (\x -> 1 + sum x)

-- | Collect all free variable names (used by the verification module).
collectVars :: Expr -> Set Text
collectVars = cata (\case
  VarF v  -> Set.singleton v
  other   -> foldr Set.union Set.empty other)

-- ─────────────────────────────────────────────────────────────────────────────
-- Bootstrapping
-- ─────────────────────────────────────────────────────────────────────────────

-- | The agent's initial Expr — a simple recursive factorial-like function
-- that the evolutionary loop will attempt to optimise over time.
bootstrapExpr :: Expr
bootstrapExpr =
  letE "factorial"
    (lam "n"
      (ifE (binop "==" (var "n") (lit 0))
           (lit 1)
           (binop "*" (var "n") (app (var "factorial") (binop "-" (var "n") (lit 1))))))
    (app (var "factorial") (lit 10))

-- | Convert an @Expr@ into the opaque 'ASTNode' format used by the rest of
-- the pipeline (archive, verification, GADT classification).
exprToASTNode :: Text -> Expr -> ASTNode
exprToASTNode nodeId = para nodeAlg
  where
    nodeAlg :: ExprF (Fix ExprF, ASTNode) -> ASTNode
    nodeAlg children =
      let childNodes = map snd (foldr (:) [] children)
          (ty, val)  = inferTypeAndVal (fmap fst children)
      in  ASTNode
            { astId       = nodeId
            , astType     = ty
            , astChildren = childNodes
            , astValue    = val
            }

    inferTypeAndVal :: ExprF Expr -> (ASTNodeType, Maybe Text)
    inferTypeAndVal = \case
      LitF  n     -> (LiteralNode,     Just (T.pack (show n)))
      BoolF b     -> (LiteralNode,     Just (if b then "True" else "False"))
      VarF  v     -> (ExprNode,        Just v)
      AppF  _ _   -> (ApplicationNode, Nothing)
      LamF  v _   -> (LambdaNode,      Just v)
      LetF  v _ _ -> (LetNode,         Just v)
      IfF   _ _ _ -> (ExprNode,        Nothing)
      BinOpF op _ _ -> (ExprNode,      Just op)
      UnitF         -> (LiteralNode,   Just "()")
